\documentclass{article}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{isolatin1}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{hyperref}
\usepackage{enumitem}

\newenvironment{itemize*}%
  {\vspace*{.1cm}\begin{itemize}%
      \setlength{\itemsep}{0pt}%
      \setlength{\parskip}{0pt}}%
  {\end{itemize}\vspace*{.1cm}}

\begin{document}
\title{IFT 615: Devoir 1\\ Travail individuel}
\author{Remise: 10 février 2012, 12h20 ({\bf au plus tard})}
\date{}
\maketitle

\begin{enumerate}[itemsep=20pt]
\item {\bf [2 points]} Pour les 2 jeux suivants, déterminer les 6
  caractéristiques de leur environnement:
  \begin{enumerate}
  \item Pong (\url{http://fr.wikipedia.org/wiki/Pong}),
  \item Monopoly (\url{http://fr.wikipedia.org/wiki/Monopoly}).
  \end{enumerate}
  Justifiez brièvement votre choix pour chaque caractéristique.

\item {\bf [2 points]} Soit le graphe suivant:
  \begin{center}
    \includegraphics[width=0.7\textwidth]{a_star_graphe}
  \end{center}
  où le noeud de départ est A, le noeud de destination (but) est H, le
  nombre près de chaque arrête est le coût de la traverser et le tableau
  à gauche décrit l'heuristique à utiliser.
  \begin{enumerate}
  \item Simulez à la main l'exécution de A*, en donnant la valeur 
    de {\it open} au début de chaque itération, ainsi que la solution
    retournée (voir acétate 21 du cours sur la recherche heuristique).
    \item Est-ce que l'heuristique est admissible? Pourquoi?
    \item Est-ce que l'heuristique est cohérente ({\it consistent})?
      Pourquoi?
  \end{enumerate}

\item {\bf [2 points]} Prouvez que, lors de l'insertion d'un noeud $n$ dans {\it open}
  durant l'exécution de A*, la valeur de $f(n)$ est plus petite ou égale
  à la vraie valeur $f^*(n)$ du chemin optimal passant par $n$. Pour
  ce faire, faites une preuve séparée pour les deux cas possibles, soient:
  \begin{enumerate}
    \item $n$ est déjà attaché à son chemin optimal (cas trivial),
    \item $n$ n'est pas encore attaché à son chemin optimal (conseil:
      faites une preuve par contradiction).
  \end{enumerate}

\item {\bf [2 points]} Dans le contexte du problème de coloriage de la carte de
  l'Australie vu en cours, montrez comment l'algorithme AC-3 peut
  détecter que l'assignation partielle {\it WA=G, V=R} n'est pas
  compatible avec les contraintes du problème.

\item {\bf [2 points]} Programmez un joueur optimal de {\it tic-tac-toe} en implémentant
  l'algorithme de recherche alpha-beta. La recherche alpha-beta
  devra donc se faire jusqu'à la profondeur maximale. 

  Le programme doit être dans le langage Python. Plus spécifiquement,
  vous devez remettre {\bf un seul fichier nommé} {\tt solution.py} contenant une
  fonction nommée {\tt joueur\_alpha\_beta\_tic\_tac\_toe} prenant 4
  arguments (dans l'ordre):
  \begin{itemize*}
  \item {\tt etat}: objet représentant l'état actuel du jeu,
  \item {\tt transitions}: une fonction acceptant un état comme
    argument et donnant en sortie un dictionnaire qui associe chaque
    action possible (clé du dictionnaire) à l'état qui en résulte
    (valeur du dictionnaire),
  \item {\tt but}: une fonction d'utilité prenant un état en argument
    et qui retourne l'utilité associée à l'état (grand nombre positif
    si le joueur {\tt 'X'} gagne, grand nombre négatif s'il perd, 0 si
    c'est une partie nulle). Si l'état ne correspond pas à une partie
    terminée, {\tt but} retourne {\tt None},
  \item {\tt joueur}: le rôle joué par ce joueur, c'est-à-dire {\tt
      'X'} ou {\tt 'O'} (sous forme d'une chaîne de caractères).
  \end{itemize*}
  La fonction {\tt joueur\_alpha\_beta\_tic\_tac\_toe} doit retourner l'action 
  prise par votre joueur. Cette action doit donc être une clé valide du dictionnaire
  retourné par {\tt transitions}.

  Le script Python {\tt devoir\_1.py} importera la fonction {\tt
    joueur\_alpha\_beta\_tic\_tac\_toe} contenue dans {\tt
    solution.py} (qui doit être dans le même répertoire) et
  l'utilisera pour simuler le joueur {\tt 'X'}. Pour tester votre
  code, vous pouvez jouer vous-même le joueur {\tt 'O'}, invoquer un joueur
  aléatoire ou utiliser la même fonction {\tt
    joueur\_alpha\_beta\_tic\_tac\_toe}. Voici comment utiliser
  {\tt devoir\_1.py}:
\begin{verbatim}
Usage: python devoir_1.py jeu adversaire

où "jeu" est "tic-tac-toe" ou "connect4"
et "adversaire" est "humain", "soi-meme" ou "aleatoire".
\end{verbatim}
  La correction de votre code se fera
  de façon automatique, en vérifiant automatiquement l'ensemble des états
  visités par votre recherche alpha-beta. Puisque l'ensemble des états
  visités dépend de l'ordre dans lequel les états successeurs sont générés,
  on vous demande de toujours utiliser l'ordre suggéré par Python
  en itérant sur les items du dictionnaire:
\begin{verbatim}
for action,nouvel_etat in transitions(etat).items():
    # Votre code
    ...

\end{verbatim}
  Votre fichier {\tt solution.py} doit être remis via l'outil {\bf turnin}
  avant la date limite de remise. 

\item {\bf [BONUS]} Implémenter également un joueur pour le jeu
  Connect~4 (Puissance 4:
  \url{http://fr.wikipedia.org/wiki/Puissance_4}). 
  Normalement, votre code pour le tic-tac-toe
  devrait également fonctionner pour Connect~4. Par contre, une
  recherche jusqu'à la profondeur maximale est trop lente dans le cas
  de Connect~4. Ainsi, vous devrez l'ajuster afin de limiter la
  profondeur de la recherche et développer une heuristique pour
  compenser. Plus votre heuristique sera bonne, plus les chances de 
  gagner de votre joueur seront bonnes.

  Pour ce faire, ajoutez une fonction {\tt
    joueur\_alpha\_beta\_connect4} à votre fichier {\tt solution.py}. Cette
  fonction doit prendre les mêmes arguments que {\tt
    joueur\_alpha\_beta\_tic\_tac\_toe}, en plus d'un cinquième argument: 
  \begin{itemize*}
  \item {\tt temps\_maximal}: le temps maximal, en secondes, accordé
    au joueur pour retourner une action.
  \end{itemize*}
  Si le joueur prend plus de 50\% du temps maximal accordé pour choisir une action,
  il sera éliminé et perdra par défaut. Le temps excédant pris par le joueur
  est également retranché au temps accordé à son tour suivant.

  Pour tenir compte du temps écoulé, vous pouvez utiliser le module
  standard {\tt time} et sa fonction {\tt time()} qui retourne le
  temps (en secondes) écoulé depuis le $1^{\rm er}$ janvier 1970 (pour
  les systèmes Unix). Plus de détails sur le module {\tt time} sont
  disponibles ici:
  \url{http://docs.python.org/library/time.html}.

  Pour développer votre heuristique, vous pourrez évaluer la qualité
  d'un état à partir du champ {\tt etat.tableau} de celui-ci. Ce
  champs est un tableau Numpy de caractères. Il contient l'information
  sur l'occupation de chaque case du jeu, à toutes les positions
  possibles: chaque entrée vaut donc {\tt 'X'}, {\tt 'O'} ou {\tt ' '}
  (pour une case non-occupée). Par exemple, l'état du jeu
\begin{verbatim}
| | | | | | | | |
| | | | | | | | |
| |X| | | | | | |
| |X| |O| | | | |
| |X| |O| | | | |
| |X| |O| | |O|X|
-----------------
 0 1 2 3 4 5 6 7
\end{verbatim}
  correspond à la valeur de {\tt etat.tableau} suivante:
\begin{verbatim}
[[' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ']
 [' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ']
 [' ' 'X' ' ' ' ' ' ' ' ' ' ' ' ']
 [' ' 'X' ' ' 'O' ' ' ' ' ' ' ' ']
 [' ' 'X' ' ' 'O' ' ' ' ' ' ' ' ']
 [' ' 'X' ' ' 'O' ' ' ' ' 'O' 'X']]
\end{verbatim}

  L'évaluation de votre solution se fera sous la forme d'un tournoi,
  où tous les joueurs soumis auront à joueur un contre l'autre. {\bf Deux
  points boni} seront accordés aux 5 meilleurs joueurs du
  tournoi. {\bf Un point boni} ira aux 5 suivants. Par contre, pour obtenir
  ces points, les joueurs devront également avoir fait mieux qu'un
  joueur (gardé secret) utilisant une heuristique très simple.

\end{enumerate}

\end{document}
